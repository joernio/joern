package io.joern.solidity2cpg.vulnerability

import io.joern.solidity2cpg.testfixtures.SolidityCodeToCpgFixture
import io.shiftleft.codepropertygraph.generated.nodes.AstNode
import io.shiftleft.codepropertygraph.generated.{Operators, nodes}
import io.shiftleft.semanticcpg.language.{ICallResolver, NoResolve, toNodeTypeStarters, _}

class OverflowTest extends SolidityCodeToCpgFixture {
  implicit val resolver: ICallResolver = NoResolve
  override val code: String = {
    """
      |pragma solidity ^0.8.0;
      |
      |contract overflow {
      |    int sellerBalance;
      |    constructor(){
      |     sellerBalance = 0;
      |    }
      |    function add(int value) public  {
      |        sellerBalance += value; // possible overflow
      |    }
      |
      |    function safe_add(int value) public {
      |        require(value + sellerBalance >= sellerBalance, "Overflow");
      |        sellerBalance += value;
      |    }
      |}""".stripMargin
  }

  "should throw overflow" in {
    {
      def overflowableArguments = cpg.call
        .nameExact(Operators.addition, Operators.assignmentPlus)
        .where(_.argument.typ.fullNameExact("int", "long"))
        .filterNot(_.argument.isLiteral.size == 2)
        .argument

      val argSet: Set[AstNode] = overflowableArguments.collect { case x: AstNode => x }.toSet
      overflowableArguments
        .whereNot(
          _.dominatedBy
            .containsCallTo(".*require.*")
            .filter(_.ast.exists(argSet.contains))
        )
        .astParent
        .isExpression
        .dedup

    }.l.foreach(x => x.traversal.method.name.l shouldBe List("add"))

  }
}
