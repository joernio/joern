package io.joern.solidity2cpg.vulnerability

import io.joern.solidity2cpg.testfixtures.SolidityCodeToCpgFixture
import io.shiftleft.codepropertygraph.generated.nodes.AstNode
import io.shiftleft.codepropertygraph.generated.{Operators, nodes}
import io.shiftleft.semanticcpg.language.{toNodeTypeStarters, ICallResolver, NoResolve, _}

class SuicideTest extends SolidityCodeToCpgFixture {
  implicit val resolver: ICallResolver = NoResolve
  override val code: String =
    """
        |pragma solidity ^0.8.0;
        |
        |contract Foo {
        |    address payable owner;
        |    uint256 public sum;
        |    function selfDestructSafe() public  {
        |        require (msg.sender == owner , "not owner");
        |        selfdestruct(owner);
        |    }
        |    function selfDestructUnsafe() public  {
        |        selfdestruct(owner);
        |    }
        |
        |    function change(uint256 a) public {
        |        sum = a;
        |    }
        |}
        |""".stripMargin
  "should throw unsafe selfDestruct" in {
    {
      def selfDestructCalls = cpg.call
        .nameExact("selfdestruct")
        .argument
      val argSet: Set[AstNode] = selfDestructCalls.collect { case x: AstNode => x }.toSet
      selfDestructCalls
        .whereNot(
          _.dominatedBy
            .containsCallTo(".*require.*")
            .filter(_.ast.exists(argSet.contains))
        )
        .astParent
        .isExpression
        .dedup

    }.l.foreach(x => x.traversal.method.name.l shouldBe List("selfDestructUnsafe"))
  }
}
