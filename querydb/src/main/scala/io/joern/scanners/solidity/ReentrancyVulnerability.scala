package io.joern.scanners.solidity
import io.joern.scanners._
import io.shiftleft.semanticcpg.language._
import io.joern.console._
import io.joern.macros.QueryMacros._
import io.joern.dataflowengineoss.language._
import io.joern.dataflowengineoss.queryengine.EngineContext
import io.shiftleft.codepropertygraph.generated.{ModifierTypes, Operators}
import io.shiftleft.codepropertygraph.generated.nodes.AstNode
object ReentrancyVulnerability extends QueryBundle {
  implicit val resolver: ICallResolver = NoResolve

  @q
  def isReentrancyVulnerability: Query =
    Query.make(
      name = "reentrancy-contract",
      author = Crew.tam,
      title = "isReentrancyVulnerability method is able to check the Reentrancy attack vulnerability pattern",
      description =
        """
          |An Attacker can use a send function many times before updating the balance of their account,
          |thus allowing the attacker to drain a contracts currency.
          |""".stripMargin,
      score = 5,
      withStrRep({ cpg =>
      {
        cpg.call
          .name(".*send.*")
          .receiver
          .whereNot(_.dominates.containsCallTo(".*revert.*"))
      }
      }),
      tags = List(QueryTags.reentrancy, QueryTags.default),
      codeExamples = CodeExamples(List(
        """
          |pragma solidity ^0.8.0;
          |
          |contract Foo {
          |
          |  address payable winner = payable(msg.sender);
          |  bool prizePaidOut;
          |  bool gameHasEnded;
          |
          |  function send_payment() public {
          |    if (gameHasEnded && !(prizePaidOut)) {
          |      winner.send(1000); // send a prize to the winner
          |      prizePaidOut = true;
          |    }
          |  }
          |
          |  function safe_send_payment() public {
          |    if (gameHasEnded && !(prizePaidOut)) {
          |      if (winner.send(1000))
          |        prizePaidOut = true;
          |      else revert();
          |    }
          |  }
          |
          |}
          |""".stripMargin), List(
        """
          |pragma solidity ^0.8.0;
          |
          |contract Foo {
          |
          |  address payable winner = payable(msg.sender);
          |  bool prizePaidOut;
          |  bool gameHasEnded;
          |
          |  function send_payment() public {
          |    if (gameHasEnded && !(prizePaidOut)) {
          |      winner.send(1000); // send a prize to the winner
          |      prizePaidOut = true;
          |    }
          |  }
          |
          |  function safe_send_payment() public {
          |    if (gameHasEnded && !(prizePaidOut)) {
          |      if (winner.send(1000))
          |        prizePaidOut = true;
          |      else revert();
          |    }
          |  }
          |
          |}
          |""".stripMargin))
    )
}
