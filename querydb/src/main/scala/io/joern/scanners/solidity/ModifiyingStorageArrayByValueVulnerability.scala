package io.joern.scanners.solidity
import io.joern.scanners._
import io.shiftleft.semanticcpg.language._
import io.joern.console._
import io.joern.macros.QueryMacros._
import io.joern.dataflowengineoss.language._
import io.joern.dataflowengineoss.queryengine.EngineContext
import io.shiftleft.codepropertygraph.generated.Operators
import io.shiftleft.codepropertygraph.generated.nodes.AstNode
object ModifiyingStorageArrayByValueVulnerability extends QueryBundle {
  implicit val resolver: ICallResolver = NoResolve

  @q
  def isModifiyingStorageArrayByValue: Query =
    Query.make(
      name = "modifiying-storage-array-by-value-contract",
      author = Crew.tam,
      title = "isModifiyingStorageArrayByValue method is able to check the change of storage allocation in arrays",
      description = """
          |A Creator has two storage options, `storage` and `memory`, storage is by reference and memory is by value,
          | this means that when adding to a storage variable the value will be stored in the memory of the contract,
          | while memory will be volatile and will not be stored in the memory of a contract. This check is to see if this is intended
          | by the creator.
          |""".stripMargin,
      score = 2,
      withStrRep({ cpg =>
        {
          def findEditByValue = cpg.method.parameter
            .whereNot(_.typeFullName("storage"))
            .where(_.typeFullName(".*\\[\\]"))
          findEditByValue
        }

      }),
      tags = List(QueryTags.modifyingStorageArrayByValue, QueryTags.default),
      codeExamples = CodeExamples(
        List("""
          |pragma solidity ^0.8.0;
          |contract Memory {
          |    uint[1] public x; // storage
          |
          |    function f() public {
          |        f1(x); // update x
          |        f2(x); // do not update x
          |    }
          |
          |    function f1(uint[1] storage arr) internal { // by reference
          |        arr[0] = 1;
          |    }
          |
          |    function f2(uint[1] arr) internal { // by value
          |        arr[0] = 2;
          |    }
          |}
          |""".stripMargin),
        List("""
          |pragma solidity ^0.8.0;
          |contract Memory {
          |    uint[1] public x; // storage
          |
          |    function f() public {
          |        f1(x); // update x
          |        f2(x); // do not update x
          |    }
          |
          |    function f1(uint[1] storage arr) internal { // by reference
          |        arr[0] = 1;
          |    }
          |
          |    function f2(uint[1] arr) internal { // by value
          |        arr[0] = 2;
          |    }
          |}
          |""".stripMargin)
      )
    )
}
